From 25093f4eb43f9f0e1fbe10d6d83afcbe939e56ca Mon Sep 17 00:00:00 2001
From: Agarwal Ashish <ashishka@codeaurora.org>
Date: Thu, 16 May 2013 12:52:48 +0530
Subject: [PATCH 2/3] wlan: GO should not follow STA channel if channel is
 passive.

When Country Code is USA, GO is always following STA channel.
If channel is Passive in that case GO should not follow
STA channel. Initially beacon hint was disabled at the time
of wiphy registration and with US country Code only.
Now Beacon hint got disabled for all the country.

CRs-Fixed: 487982,487968
Change-Id: Ic8c9ac23d8e7a5db30233e51412107eee93a50f0

Conflicts:
	CORE/VOSS/src/vos_nvitem.c
---
 CORE/HDD/src/wlan_hdd_cfg80211.c |   9 +-
 CORE/VOSS/src/vos_nvitem.c       | 260 ++++++++++++++++++++-------------------
 2 files changed, 136 insertions(+), 133 deletions(-)

diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 2000f77..6444c1e 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -645,6 +645,9 @@ int wlan_hdd_cfg80211_init(struct device *dev,
     }
     else
     {
+       /* This will disable updating of NL channels from passive to
+        * active if a beacon is received on passive channel. */
+       wiphy->flags |=   WIPHY_FLAG_DISABLE_BEACON_HINTS;
        wiphy->flags |=   WIPHY_FLAG_STRICT_REGULATORY;
     }
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
@@ -844,12 +847,6 @@ void wlan_hdd_cfg80211_update_reg_info(struct wiphy *wiphy)
     }
     if ((defaultCountryCode[0]== 'U') && (defaultCountryCode[1]=='S'))
     {
-       /* This will disable updating of NL channels from passive to
-          active if a beacon is received on passive channel.
-          If this flag is not disabled then nl can change passive channel to
-          active channels.
-       */
-       wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS;
        if (NULL == wiphy->bands[IEEE80211_BAND_5GHZ])
        {
           hddLog(VOS_TRACE_LEVEL_ERROR,"%s: wiphy->bands[IEEE80211_BAND_5GHZ] is NULL",__func__ );
diff --git a/CORE/VOSS/src/vos_nvitem.c b/CORE/VOSS/src/vos_nvitem.c
index 64c1b69..ef80f0c 100644
--- a/CORE/VOSS/src/vos_nvitem.c
+++ b/CORE/VOSS/src/vos_nvitem.c
@@ -2361,143 +2361,149 @@ int wlan_hdd_crda_reg_notifier(struct wiphy *wiphy,
        // sme_ChangeCountryCode(pHddCtx->hHal, NULL,
        //    &country_code[0], pAdapter, pHddCtx->pvosContext);
     }
-    else if (request->initiator == NL80211_REGDOM_SET_BY_DRIVER)
+    else if (request->initiator == NL80211_REGDOM_SET_BY_DRIVER ||
+             (request->initiator == NL80211_REGDOM_SET_BY_CORE))
     {
-         if ( eHAL_STATUS_SUCCESS !=  sme_GetCountryCode(pHddCtx->hHal, ccode, &uBufLen))
-         {
-            wiphy_dbg(wiphy, "info: set by driver CCODE ERROR\n");
-            return 0;
-         }
-         if (eHAL_STATUS_SUCCESS != sme_GetRegulatoryDomainForCountry (pHddCtx->hHal,
-                                             ccode, (v_REGDOMAIN_t *) &domainIdCurrent))
-         {
-            wiphy_dbg(wiphy, "info: set by driver ERROR\n");
-            return 0;
-         }
-         wiphy_dbg(wiphy, "country: %c%c set by driver\n",ccode[0],ccode[1]);
+       if ( eHAL_STATUS_SUCCESS !=  sme_GetCountryCode(pHddCtx->hHal, ccode, &uBufLen))
+       {
+          wiphy_dbg(wiphy, "info: set by driver CCODE ERROR\n");
+          return 0;
+       }
+       if (eHAL_STATUS_SUCCESS != sme_GetRegulatoryDomainForCountry (pHddCtx->hHal,
+                                           ccode, (v_REGDOMAIN_t *) &domainIdCurrent))
+       {
+          wiphy_dbg(wiphy, "info: set by driver ERROR\n");
+          return 0;
+       }
+       wiphy_dbg(wiphy, "country: %c%c set by driver\n",ccode[0],ccode[1]);
        /* if set by driver itself, it means driver can accept the crda
           regulatory settings and wiphy->regd should be populated with crda
           settings. iwiphy->bands doesn't seem to set ht40 flags in kernel
           correctly, this may be fixed by later kernel */
-         if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
-                          CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) != 0)
-         {
-            if (create_crda_regulatory_entry_from_regd(wiphy, request, pHddCtx->cfg_ini->nBandCapability) == 0)
-            {
-               pr_info("crda entry created.\n");
-               if (crda_alpha2[0] == request->alpha2[0] && crda_alpha2[1] == request->alpha2[1])
-               {  /* first CRDA request should be from init time */
-                  /* Change default country code to CRDA country code, assume indoor */
-                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0] = request->alpha2[0];
-                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1] = request->alpha2[1];
-                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2] = 'I';
-                  pnvEFSTable->halnv.tables.defaultCountryTable.regDomain = NUM_REG_DOMAINS-1;
-                  wiphy_dbg(wiphy, "info: init time default country code is %c%c%c\n",
-                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0],
-                      pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1],
-                         pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2]);
-               }
-               else /* second or later CRDA request after init time */
-               {
-                  wiphy_dbg(wiphy, "info: crda none-default country code is %c%c\n",
-                      request->alpha2[0], request->alpha2[1]);
-               }
-               // hdd will read regd for this country after complete
-            }
-            complete(&pHddCtx->driver_crda_req);
-         }
-         else
-         {
-            nBandCapability = pHddCtx->cfg_ini->nBandCapability;
-            for (i=0, m=0; i<IEEE80211_NUM_BANDS; i++)
-            {
+       if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
+                         CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) != 0)
+       {
+          if (create_crda_regulatory_entry_from_regd(wiphy, request, pHddCtx->cfg_ini->nBandCapability) == 0)
+          {
+             pr_info("crda entry created.\n");
+             if (crda_alpha2[0] == request->alpha2[0] && crda_alpha2[1] == request->alpha2[1])
+             {
+                /* first CRDA request should be from init time */
+                /* Change default country code to CRDA country code, assume indoor */
+                pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0] = request->alpha2[0];
+                pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1] = request->alpha2[1];
+                pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2] = 'I';
+                pnvEFSTable->halnv.tables.defaultCountryTable.regDomain = NUM_REG_DOMAINS-1;
+                wiphy_dbg(wiphy, "info: init time default country code is %c%c%c\n",
+                pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0],
+                    pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1],
+                       pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2]);
+             }
+             else /* second or later CRDA request after init time */
+             {
+                wiphy_dbg(wiphy, "info: crda none-default country code is %c%c\n",
+                    request->alpha2[0], request->alpha2[1]);
+             }
+             // hdd will read regd for this country after complete
+          }
+          complete(&pHddCtx->driver_crda_req);
+       }
+       else
+       {
+          nBandCapability = pHddCtx->cfg_ini->nBandCapability;
+          for (i=0, m=0; i<IEEE80211_NUM_BANDS; i++)
+          {
+             if (NULL == wiphy->bands[i])
+             {
+                VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+                     "error: wiphy->bands[i] is NULL, i = %d", i);
+                continue;
+             }
+
+             // internal channels[] is one continous array for both 2G and 5G bands
+             // m is internal starting channel index for each band
+             if (0 == i)
+             {
+                m = 0;
+             }
+             else
+             {
+                m = wiphy->bands[i-1]?wiphy->bands[i-1]->n_channels + m:m;
+             }
+
+             for (j=0; j<wiphy->bands[i]->n_channels; j++)
+             {
+                // k = (m + j) is internal current channel index for 20MHz channel
+                // n is internal channel index for corresponding 40MHz channel
+                k = m + j;
+                if (IEEE80211_BAND_2GHZ == i && eCSR_BAND_5G == nBandCapability) // 5G only
+                {
+                   // Enable social channels for P2P
+                   if ((2412 == wiphy->bands[i]->channels[j].center_freq ||
+                       2437 == wiphy->bands[i]->channels[j].center_freq ||
+                       2462 == wiphy->bands[i]->channels[j].center_freq ) &&
+                       NV_CHANNEL_ENABLE == regChannels[k].enabled)
+                   {
+                       wiphy->bands[i]->channels[j].flags &= ~IEEE80211_CHAN_DISABLED;
+                   }
+                   else
+                   {
+                      wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
+                   }
+                   continue;
+                }
+                else if (IEEE80211_BAND_5GHZ == i && eCSR_BAND_24 == nBandCapability) // 2G only
+                {
+                   wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
+                   continue;
+                }
 
-               if (NULL == wiphy->bands[i])
-               {
-                  VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-                       "error: wiphy->bands[i] is NULL, i = %d", i);
-                  continue;
-               }
-
-               // internal channels[] is one continous array for both 2G and 5G bands
-               // m is internal starting channel index for each band
-               if (0 == i)
-                  m = 0;
-               else
-                  m = wiphy->bands[i-1]?wiphy->bands[i-1]->n_channels + m:m;
-
-               for (j=0; j<wiphy->bands[i]->n_channels; j++)
-               {
-                  // k = (m + j) is internal current channel index for 20MHz channel
-                  // n is internal channel index for corresponding 40MHz channel
-                  k = m + j;
-                  if (IEEE80211_BAND_2GHZ == i && eCSR_BAND_5G == nBandCapability) // 5G only
-                  {
-                     // Enable social channels for P2P
-                     if ((2412 == wiphy->bands[i]->channels[j].center_freq ||
-                         2437 == wiphy->bands[i]->channels[j].center_freq ||
-                         2462 == wiphy->bands[i]->channels[j].center_freq ) &&
-                         NV_CHANNEL_ENABLE == regChannels[k].enabled)
-                         wiphy->bands[i]->channels[j].flags &= ~IEEE80211_CHAN_DISABLED;
-                     else
-                         wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
-                     continue;
-                  }
-                  else if (IEEE80211_BAND_5GHZ == i && eCSR_BAND_24 == nBandCapability) // 2G only
-                  {
-                     wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
-                     continue;
-                  }
-
-                  if (NV_CHANNEL_DISABLE == regChannels[k].enabled ||
-                     NV_CHANNEL_INVALID == regChannels[k].enabled)
-                  {
-                     wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
-                  }
-                  else if (NV_CHANNEL_DFS == regChannels[k].enabled)
-                  {
-                     wiphy->bands[i]->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
-                                                            |IEEE80211_CHAN_RADAR);
-                     wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
-                  }
-                  else
-                  {
-                     wiphy->bands[i]->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
-                                                             |IEEE80211_CHAN_PASSIVE_SCAN
-                                                            |IEEE80211_CHAN_RADAR);
-                  }
-               }
-            }
-            /* Haven't seen any condition that will set by driver after init.
-             If we do, then we should also call sme_ChangeCountryCode */
-            for (j=0; j<wiphy->bands[IEEE80211_BAND_5GHZ ]->n_channels; j++)
-            {
-                // p2p UNII-1 band channels are passive when domain is FCC.
-                if ((wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].center_freq == 5180 ||
-                               wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5200 ||
-                               wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5220 ||
-                               wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5240) &&
-                               (ccode[0]== 'U'&& ccode[1]=='S'))
+                if (NV_CHANNEL_DISABLE == regChannels[k].enabled ||
+                    NV_CHANNEL_INVALID == regChannels[k].enabled)
                 {
-                   wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+                   wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
                 }
-                else if ((wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].center_freq == 5180 ||
-                                    wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5200 ||
-                                    wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5220 ||
-                                    wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5240) &&
-                                    (ccode[0]!= 'U'&& ccode[1]!='S'))
+                else if (NV_CHANNEL_DFS == regChannels[k].enabled)
                 {
-                   wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+                   wiphy->bands[i]->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
+                                                          |IEEE80211_CHAN_RADAR);
+                   wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
                 }
-            }
-         }
-    }
-    else if (request->initiator == NL80211_REGDOM_SET_BY_CORE)
-    {
-       if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
-                        CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) == 0)
-       {
-          request->processed = 1;
+                else
+                {
+                   wiphy->bands[i]->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
+                                                          |IEEE80211_CHAN_PASSIVE_SCAN
+                                                          |IEEE80211_CHAN_NO_IBSS
+                                                          |IEEE80211_CHAN_RADAR);
+                }
+             }
+          }
+          /* Haven't seen any condition that will set by driver after init.
+           If we do, then we should also call sme_ChangeCountryCode */
+          for (j=0; j<wiphy->bands[IEEE80211_BAND_5GHZ ]->n_channels; j++)
+          {
+              // p2p UNII-1 band channels are passive when domain is FCC.
+              if ((wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].center_freq == 5180 ||
+                             wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5200 ||
+                             wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5220 ||
+                             wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5240) &&
+                             (ccode[0]== 'U'&& ccode[1]=='S'))
+              {
+                 wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+              }
+              else if ((wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].center_freq == 5180 ||
+                                  wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5200 ||
+                                  wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5220 ||
+                                  wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5240) &&
+                                  (ccode[0]!= 'U'&& ccode[1]!='S'))
+              {
+                 wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+              }
+          }
+          if (request->initiator == NL80211_REGDOM_SET_BY_CORE)
+          {
+              request->processed = 1;
+          }
        }
     }
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
-- 
1.8.2

