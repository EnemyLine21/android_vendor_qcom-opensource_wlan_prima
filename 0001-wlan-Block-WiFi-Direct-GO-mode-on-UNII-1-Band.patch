From 5ad104ebe4f5292a19b0539649fefb365259d483 Mon Sep 17 00:00:00 2001
From: Agarwal Ashish <ashishka@codeaurora.org>
Date: Fri, 12 Apr 2013 22:00:48 +0530
Subject: [PATCH 1/3] wlan:Block WiFi Direct GO mode on UNII-1 Band.

Make UNII-1 Band channels to passive channel.
GO shouldn't be started on UNII-1 band channels
(36,38,40,42,44,46,48) if regulatory domain is FCC.

CRs-Fixed: 472846
Change-Id: I87b2cc3ff6e634ef8a57cc5c0c60c3dcc151ee87
---
 CORE/HDD/inc/wlan_hdd_cfg80211.h |   5 +-
 CORE/HDD/inc/wlan_hdd_main.h     |   5 +
 CORE/HDD/src/wlan_hdd_cfg80211.c |  76 ++++++++++--
 CORE/HDD/src/wlan_hdd_main.c     |  33 ++++--
 CORE/HDD/src/wlan_hdd_wext.c     |   4 +-
 CORE/SME/src/csr/csrApiScan.c    |   8 +-
 CORE/VOSS/src/vos_nvitem.c       | 246 ++++++++++++++++++++++++---------------
 7 files changed, 252 insertions(+), 125 deletions(-)

diff --git a/CORE/HDD/inc/wlan_hdd_cfg80211.h b/CORE/HDD/inc/wlan_hdd_cfg80211.h
index b337028..2db7bda 100644
--- a/CORE/HDD/inc/wlan_hdd_cfg80211.h
+++ b/CORE/HDD/inc/wlan_hdd_cfg80211.h
@@ -137,7 +137,7 @@ int wlan_hdd_cfg80211_pmksa_candidate_notify(
 void wlan_hdd_cfg80211_set_key_wapi(hdd_adapter_t* pAdapter,
               u8 key_index, const u8 *mac_addr, u8 *key , int key_Len);
 #endif
-struct wiphy *wlan_hdd_cfg80211_init(int priv_size);
+struct wiphy *wlan_hdd_cfg80211_wiphy_alloc(int priv_size);
 
 int wlan_hdd_cfg80211_scan( struct wiphy *wiphy,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
@@ -145,11 +145,12 @@ int wlan_hdd_cfg80211_scan( struct wiphy *wiphy,
 #endif
                             struct cfg80211_scan_request *request);
 
-int wlan_hdd_cfg80211_register(struct device *dev,
+int wlan_hdd_cfg80211_init(struct device *dev,
                                struct wiphy *wiphy,
                                hdd_config_t *pCfg
                                          );
 
+int wlan_hdd_cfg80211_register( struct wiphy *wiphy);
 void wlan_hdd_cfg80211_post_voss_start(hdd_adapter_t* pAdapter);
 
 void wlan_hdd_cfg80211_pre_voss_stop(hdd_adapter_t* pAdapter);
diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index 3603dd8..9743334 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -171,6 +171,10 @@
 #define WLAN_HDD_IS_SOCIAL_CHANNEL(center_freq) \
 (((center_freq) == 2412) || ((center_freq) == 2437) || ((center_freq) == 2462))
 
+#define WLAN_HDD_CHANNEL_IN_UNII_1_BAND(center_freq) \
+(((center_freq) == 5180 ) || ((center_freq) == 5200) \
+|| ((center_freq) == 5220) || ((center_freq) == 5240))
+
 #ifdef WLAN_FEATURE_11W
 #define WLAN_HDD_SA_QUERY_ACTION_FRAME 8
 #endif
@@ -1079,6 +1083,7 @@ void hdd_set_ssr_required(e_hdd_ssr_required value);
 VOS_STATUS hdd_enable_bmps_imps(hdd_context_t *pHddCtx);
 VOS_STATUS hdd_disable_bmps_imps(hdd_context_t *pHddCtx, tANI_U8 session_type);
 
+void wlan_hdd_cfg80211_update_reg_info(struct wiphy *wiphy);
 VOS_STATUS wlan_hdd_restart_driver(hdd_context_t *pHddCtx);
 void hdd_exchange_version_and_caps(hdd_context_t *pHddCtx);
 void hdd_set_pwrparams(hdd_context_t *pHddCtx);
diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 4b7091f..6e7eb6b 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -504,12 +504,12 @@ static struct index_vht_data_rate_type supported_vht_mcs_rate[] =
 extern struct net_device_ops net_ops_struct;
 
 /*
- * FUNCTION: wlan_hdd_cfg80211_init
+ * FUNCTION: wlan_hdd_cfg80211_wiphy_alloc
  * This function is called by hdd_wlan_startup()
  * during initialization.
- * This function is used to initialize and register wiphy structure.
+ * This function is used to allocate wiphy structure.
  */
-struct wiphy *wlan_hdd_cfg80211_init(int priv_size)
+struct wiphy *wlan_hdd_cfg80211_wiphy_alloc(int priv_size)
 {
     struct wiphy *wiphy;
     ENTER();
@@ -598,23 +598,28 @@ int wlan_hdd_cfg80211_update_band(struct wiphy *wiphy, eCsrBand eBand)
  * during initialization.
  * This function is used to initialize and register wiphy structure.
  */
-int wlan_hdd_cfg80211_register(struct device *dev,
+int wlan_hdd_cfg80211_init(struct device *dev,
                                struct wiphy *wiphy,
                                hdd_config_t *pCfg
                                )
 {
-
     int i, j;
-
+    hdd_context_t *pHddCtx = wiphy_priv(wiphy);
     ENTER();
 
     /* Now bind the underlying wlan device with wiphy */
     set_wiphy_dev(wiphy, dev);
 
     wiphy->mgmt_stypes = wlan_hdd_txrx_stypes;
-
-    wiphy->flags |=   WIPHY_FLAG_CUSTOM_REGULATORY;
-
+    if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
+                      CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) != 0)
+    {
+       wiphy->flags |=   WIPHY_FLAG_CUSTOM_REGULATORY;
+    }
+    else
+    {
+       wiphy->flags |=   WIPHY_FLAG_STRICT_REGULATORY;
+    }
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
     wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME
                  |  WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD
@@ -741,10 +746,18 @@ int wlan_hdd_cfg80211_register(struct device *dev,
     wiphy->max_remain_on_channel_duration = 1000;
 #endif
 
-    /* Register our wiphy dev with cfg80211 */
+    EXIT();
+    return 0;
+}
+
+/* In this function we are registering wiphy. */
+int wlan_hdd_cfg80211_register(struct wiphy *wiphy)
+{
+    ENTER();
+ /* Register our wiphy dev with cfg80211 */
     if (0 > wiphy_register(wiphy))
     {
-        /* print eror */
+        /* print error */
         hddLog(VOS_TRACE_LEVEL_ERROR,"%s: wiphy register failed", __func__);
         return -EIO;
     }
@@ -757,7 +770,7 @@ int wlan_hdd_cfg80211_register(struct device *dev,
    If the gCrdaDefaultCountryCode is configured in ini file,
    we will try to call user space crda to get the regulatory settings for
    that country. We will timeout if we can't get it from crda.
-   It's called by hdd_wlan_startup() after wlan_hdd_cfg80211_register.
+   It's called by hdd_wlan_startup() after wlan_hdd_cfg80211_init.
 */
 int wlan_hdd_get_crda_regd_entry(struct wiphy *wiphy, hdd_config_t *pCfg)
 {
@@ -777,6 +790,45 @@ int wlan_hdd_get_crda_regd_entry(struct wiphy *wiphy, hdd_config_t *pCfg)
    return 0;
 }
 
+/* In this function we are updating channel list when,
+   regulatory domain is FCC and country code is US.
+   Here In FCC standard 5GHz UNII-1 Bands are indoor only.
+   As per FCC smart phone is not a indoor device.
+   GO should not opeate on indoor channels */
+void wlan_hdd_cfg80211_update_reg_info(struct wiphy *wiphy)
+{
+    int j;
+    hdd_context_t *pHddCtx = wiphy_priv(wiphy);
+    tANI_U8 defaultCountryCode[3] = SME_INVALID_COUNTRY_CODE;
+    //Default counrtycode from NV at the time of wiphy initialization.
+    if (eHAL_STATUS_SUCCESS != sme_GetDefaultCountryCodeFrmNv(pHddCtx->hHal,
+                                  &defaultCountryCode[0]))
+    {
+       hddLog(LOGE, FL("%s Failed to get default country code from NV"));
+    }
+    if ((defaultCountryCode[0]== 'U') && (defaultCountryCode[1]=='S'))
+    {
+       /* This will disable updating of NL channels from passive to
+          active if a beacon is received on passive channel.
+          If this flag is not disabled then nl can change passive channel to
+          active channels.
+       */
+       wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS;
+       if (NULL == wiphy->bands[IEEE80211_BAND_5GHZ])
+       {
+          hddLog(VOS_TRACE_LEVEL_ERROR,"%s: wiphy->bands[IEEE80211_BAND_5GHZ] is NULL",__func__ );
+          return;
+       }
+       for (j = 0; j < wiphy->bands[IEEE80211_BAND_5GHZ]->n_channels; j++)
+       {
+          struct ieee80211_supported_band *band = wiphy->bands[IEEE80211_BAND_5GHZ];
+          // Mark UNII -1 band channel as passive
+          if (WLAN_HDD_CHANNEL_IN_UNII_1_BAND(band->channels[j].center_freq))
+             band->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+       }
+    }
+}
+
 /* In this function we will do all post VOS start initialization.
    In this function we will register for all frame in which supplicant
    is interested.
diff --git a/CORE/HDD/src/wlan_hdd_main.c b/CORE/HDD/src/wlan_hdd_main.c
index afdd38f..268482e 100644
--- a/CORE/HDD/src/wlan_hdd_main.c
+++ b/CORE/HDD/src/wlan_hdd_main.c
@@ -597,6 +597,7 @@ int hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
    if ((SIOCDEVPRIVATE + 1) == cmd)
    {
        hdd_context_t *pHddCtx = (hdd_context_t*)pAdapter->pHddCtx;
+       struct wiphy *wiphy = pHddCtx->wiphy;
 
        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
                   "%s: Received %s cmd from Wi-Fi GUI***", __func__, command);
@@ -641,6 +642,14 @@ int hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
                        "%s: SME Change Country code fail ret=%d\n",__func__, ret);
 
            }
+           /* If you get a 00 country code it means you are world roaming.
+           In case of world roaming, country code should be updated by
+           DRIVER COUNTRY */
+           if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
+                            CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) == 0)
+           {
+              regulatory_hint(wiphy, "00");
+           }
        }
 #if  defined (WLAN_FEATURE_VOWIFI_11R) || defined (FEATURE_WLAN_CCX) || defined(FEATURE_WLAN_LFR)
        else if ( strncasecmp(command, "SETCOUNTRYREV", 13) == 0 )
@@ -5370,7 +5379,7 @@ int hdd_wlan_startup(struct device *dev )
    /*
     * cfg80211: wiphy allocation
     */
-   wiphy = wlan_hdd_cfg80211_init(sizeof(hdd_context_t)) ;
+   wiphy = wlan_hdd_cfg80211_wiphy_alloc(sizeof(hdd_context_t)) ;
 
    if(wiphy == NULL)
    {
@@ -5451,13 +5460,13 @@ int hdd_wlan_startup(struct device *dev )
       }
    }
    /*
-    * cfg80211: Initialization and registration ...
+    * cfg80211: Initialization  ...
     */
-   if (0 < wlan_hdd_cfg80211_register(dev, wiphy, pHddCtx->cfg_ini))
+   if (0 < wlan_hdd_cfg80211_init(dev, wiphy, pHddCtx->cfg_ini))
    {
       hddLog(VOS_TRACE_LEVEL_FATAL, 
-              "%s: wlan_hdd_cfg80211_register return failure", __func__);
-      goto err_wiphy_reg;
+              "%s: wlan_hdd_cfg80211_init return failure", __func__);
+      goto err_config;
    }
 
    // Update VOS trace levels based upon the cfg.ini
@@ -5514,7 +5523,7 @@ int hdd_wlan_startup(struct device *dev )
       if(!VOS_IS_STATUS_SUCCESS( status ))
       {
          hddLog(VOS_TRACE_LEVEL_FATAL,"%s: vos_watchdog_open failed",__func__);
-         goto err_wiphy_reg;
+         goto err_wdclose;
       }
    }
 
@@ -5673,6 +5682,14 @@ int hdd_wlan_startup(struct device *dev )
          __func__);
       goto err_vosstop;
    }
+   wlan_hdd_cfg80211_update_reg_info( wiphy );
+
+   /* registration of wiphy dev with cfg80211 */
+   if (0 > wlan_hdd_cfg80211_register(wiphy))
+   {
+       hddLog(VOS_TRACE_LEVEL_ERROR,"%s: wiphy register failed", __func__);
+       goto err_vosstop;
+   }
 
    if (VOS_STA_SAP_MODE == hdd_get_conparam())
    {
@@ -5903,6 +5920,7 @@ err_bap_close:
 
 err_close_adapter:
    hdd_close_all_adapters( pHddCtx );
+   wiphy_unregister(wiphy) ;
 
 err_vosstop:
    vos_stop(pVosContext);
@@ -5923,9 +5941,6 @@ err_wdclose:
    if(pHddCtx->cfg_ini->fIsLogpEnabled)
       vos_watchdog_close(pVosContext);
 
-err_wiphy_reg:
-   wiphy_unregister(wiphy) ; 
-
 err_config:
    kfree(pHddCtx->cfg_ini);
    pHddCtx->cfg_ini= NULL;
diff --git a/CORE/HDD/src/wlan_hdd_wext.c b/CORE/HDD/src/wlan_hdd_wext.c
index 4f28de5..e83115a 100644
--- a/CORE/HDD/src/wlan_hdd_wext.c
+++ b/CORE/HDD/src/wlan_hdd_wext.c
@@ -6433,7 +6433,7 @@ int hdd_setBand_helper(struct net_device *dev, tANI_U8* ptr)
                      &pAdapter->disconnect_comp_var,
                      msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
 
-             if(lrc <= 0) {
+             if (lrc <= 0) {
 
                 hddLog(VOS_TRACE_LEVEL_ERROR,"%s: %s while waiting for csrRoamDisconnect ",
                  __func__, (0 == lrc) ? "Timeout" : "Interrupt");
@@ -6447,7 +6447,7 @@ int hdd_setBand_helper(struct net_device *dev, tANI_U8* ptr)
 #if  defined (WLAN_FEATURE_VOWIFI_11R) || defined (FEATURE_WLAN_CCX) || defined(FEATURE_WLAN_LFR)
         sme_UpdateBgScanConfigIniChannelList(hHal, (eCsrBand) band);
 #endif
-        if(eHAL_STATUS_SUCCESS != sme_SetFreqBand(hHal, (eCsrBand)band))
+        if (eHAL_STATUS_SUCCESS != sme_SetFreqBand(hHal, (eCsrBand)band))
         {
              VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
                      "%s: failed to set the band value to %u ",
diff --git a/CORE/SME/src/csr/csrApiScan.c b/CORE/SME/src/csr/csrApiScan.c
index 24eeef7..f93dd19 100644
--- a/CORE/SME/src/csr/csrApiScan.c
+++ b/CORE/SME/src/csr/csrApiScan.c
@@ -3497,8 +3497,8 @@ void csrApplyCountryInformation( tpAniSirGlobal pMac, tANI_BOOLEAN fForce )
                 {
                    smsLog(pMac, LOGW, FL("Domain Changed Old %d, new %d"),
                                       pMac->scan.domainIdCurrent, domainId);
+                   status = WDA_SetRegDomain(pMac, domainId);
                 }
-                status = WDA_SetRegDomain(pMac, domainId);
                 if (status != eHAL_STATUS_SUCCESS)
                 {
                     smsLog( pMac, LOGE, FL("  fail to set regId %d"), domainId );
@@ -3865,8 +3865,7 @@ tANI_BOOLEAN csrLearnCountryInformation( tpAniSirGlobal pMac, tSirBssDescription
         if ( domainId != pMac->scan.domainIdCurrent )
         {
             tSirMacChanInfo* pMacChnSet = (tSirMacChanInfo *)(&pIesLocal->Country.triplets[0]);
-            WDA_SetRegDomain(pMac, domainId);
-            // Check weather AP provided the 2.4GHZ list or 5GHZ list
+            // Check whether AP provided the 2.4GHZ list or 5GHZ list
             if(CSR_IS_CHANNEL_24GHZ(pMacChnSet[0].firstChanNum))
             {
                 // AP Provided the 2.4 Channels, Update the 5GHz channels from nv.bin
@@ -3877,6 +3876,9 @@ tANI_BOOLEAN csrLearnCountryInformation( tpAniSirGlobal pMac, tSirBssDescription
                 // AP Provided the 5G Channels, Update the 2.4GHZ channel list from nv.bin
                 csrGet24GChannels(pMac );
             }
+            csrSetCfgCountryCode(pMac, pIesLocal->Country.country);
+            WDA_SetRegDomain(pMac, domainId);
+            pMac->scan.domainIdCurrent = domainId;
         }
         // Populate both band channel lists based on what we found in the country information...
         csrSetOppositeBandChannelInfo( pMac );
diff --git a/CORE/VOSS/src/vos_nvitem.c b/CORE/VOSS/src/vos_nvitem.c
index afda284..d16d5b1 100644
--- a/CORE/VOSS/src/vos_nvitem.c
+++ b/CORE/VOSS/src/vos_nvitem.c
@@ -1762,90 +1762,31 @@ VOS_STATUS vos_nv_setRegDomain(void * clientCtxt, v_REGDOMAIN_t regId)
     v_CONTEXT_t pVosContext = NULL;
     hdd_context_t *pHddCtx = NULL;
     struct wiphy *wiphy = NULL;
-    v_U8_t nBandCapability;
-    int i, j, k, m;
-
    /* Client Context Argumant not used for PRIMA */
-   if(regId >= REGDOMAIN_COUNT)
+   if (regId >= REGDOMAIN_COUNT)
    {
       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
                 "VOS set reg domain, invalid REG domain ID %d", regId);
       return VOS_STATUS_E_INVAL;
    }
 
-   /* Set correct channel information based on REG Domain */
-   regChannels = pnvEFSTable->halnv.tables.regDomains[regId].channels;
-
    pVosContext = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
    if (NULL != pVosContext)
-       pHddCtx = vos_get_context(VOS_MODULE_ID_HDD, pVosContext);
+      pHddCtx = vos_get_context(VOS_MODULE_ID_HDD, pVosContext);
    else
-       return VOS_STATUS_E_EXISTS;
-
-   if (NULL == pHddCtx)
-       return VOS_STATUS_E_EXISTS;
-
-   wiphy = pHddCtx->wiphy;
-   nBandCapability = pHddCtx->cfg_ini->nBandCapability;
+      return VOS_STATUS_E_EXISTS;
+   /* Set correct channel information based on REG Domain */
+   regChannels = pnvEFSTable->halnv.tables.regDomains[regId].channels;
 
-   for (i = 0, m = 0; i < IEEE80211_NUM_BANDS; i++)
+   /* when CRDA is not running then we are world roaming.
+      In this case if 11d is enabled, then country code should
+      be update on basis of world roaming */
+   if ((NULL != pHddCtx) && (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
+                    CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) == 0))
    {
-
-       if (NULL == wiphy->bands[i])
-       {
-          VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-                    "error: wiphy->bands[i] is NULL, i = %d", i);
-          continue;
-       }
-
-       // internal channels[] is one continous array for both 2G and 5G bands
-       // m is internal starting channel index for each band
-       if (0 == i)
-           m = 0;
-       else
-           m = wiphy->bands[i-1]?wiphy->bands[i-1]->n_channels + m:m;
-
-       for (j = 0; j < wiphy->bands[i]->n_channels; j++)
-       {
-           struct ieee80211_supported_band *band = wiphy->bands[i];
-
-           // k = (m + j) is internal current channel index for 20MHz channel
-           // n is internal channel index for corresponding 40MHz channel
-           k = m + j;
-           if (IEEE80211_BAND_2GHZ == i && eCSR_BAND_5G == nBandCapability) // 5G only
-           {
-               // Enable social channels for P2P
-               if (WLAN_HDD_IS_SOCIAL_CHANNEL(band->channels[j].center_freq) &&
-                   NV_CHANNEL_ENABLE == regChannels[k].enabled)
-                   band->channels[j].flags &= ~IEEE80211_CHAN_DISABLED;
-               else
-                   band->channels[j].flags |= IEEE80211_CHAN_DISABLED;
-               continue;
-           }
-           else if (IEEE80211_BAND_5GHZ == i && eCSR_BAND_24 == nBandCapability) // 2G only
-           {
-               band->channels[j].flags |= IEEE80211_CHAN_DISABLED;
-               continue;
-           }
-
-           if (NV_CHANNEL_DISABLE == regChannels[k].enabled ||
-               NV_CHANNEL_INVALID == regChannels[k].enabled)
-           {
-               band->channels[j].flags |= IEEE80211_CHAN_DISABLED;
-           }
-           else if (NV_CHANNEL_DFS == regChannels[k].enabled)
-           {
-               band->channels[j].flags &= ~IEEE80211_CHAN_DISABLED;
-               band->channels[j].flags |= IEEE80211_CHAN_RADAR;
-           }
-           else
-           {
-               band->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
-                                            |IEEE80211_CHAN_RADAR);
-           }
-       }
-    }
-
+      wiphy = pHddCtx->wiphy;
+      regulatory_hint(wiphy, "00");
+   }
    return VOS_STATUS_SUCCESS;
 }
 
@@ -2366,6 +2307,11 @@ int wlan_hdd_crda_reg_notifier(struct wiphy *wiphy,
                 struct regulatory_request *request)
 {
     hdd_context_t *pHddCtx = wiphy_priv(wiphy);
+    v_REGDOMAIN_t domainIdCurrent;
+    tANI_U8 ccode[WNI_CFG_COUNTRY_CODE_LEN];
+    tANI_U8 uBufLen = WNI_CFG_COUNTRY_CODE_LEN;
+    tANI_U8 nBandCapability;
+    int i,j,k,m;
     wiphy_dbg(wiphy, "info: cfg80211 reg_notifier callback for country"
                      " %c%c\n", request->alpha2[0], request->alpha2[1]);
     if (request->initiator == NL80211_REGDOM_SET_BY_USER)
@@ -2396,37 +2342,143 @@ int wlan_hdd_crda_reg_notifier(struct wiphy *wiphy,
     }
     else if (request->initiator == NL80211_REGDOM_SET_BY_DRIVER)
     {
-       wiphy_dbg(wiphy, "info: set by driver\n");
+         if ( eHAL_STATUS_SUCCESS !=  sme_GetCountryCode(pHddCtx->hHal, ccode, &uBufLen))
+         {
+            wiphy_dbg(wiphy, "info: set by driver CCODE ERROR\n");
+            return 0;
+         }
+         if (eHAL_STATUS_SUCCESS != sme_GetRegulatoryDomainForCountry (pHddCtx->hHal,
+                                             ccode, (v_REGDOMAIN_t *) &domainIdCurrent))
+         {
+            wiphy_dbg(wiphy, "info: set by driver ERROR\n");
+            return 0;
+         }
+         wiphy_dbg(wiphy, "country: %c%c set by driver\n",ccode[0],ccode[1]);
        /* if set by driver itself, it means driver can accept the crda
           regulatory settings and wiphy->regd should be populated with crda
           settings. iwiphy->bands doesn't seem to set ht40 flags in kernel
           correctly, this may be fixed by later kernel */
-       if (create_crda_regulatory_entry_from_regd(wiphy, request, pHddCtx->cfg_ini->nBandCapability) == 0)
+         if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
+                          CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) != 0)
+         {
+            if (create_crda_regulatory_entry_from_regd(wiphy, request, pHddCtx->cfg_ini->nBandCapability) == 0)
+            {
+               pr_info("crda entry created.\n");
+               if (crda_alpha2[0] == request->alpha2[0] && crda_alpha2[1] == request->alpha2[1])
+               {  /* first CRDA request should be from init time */
+                  /* Change default country code to CRDA country code, assume indoor */
+                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0] = request->alpha2[0];
+                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1] = request->alpha2[1];
+                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2] = 'I';
+                  pnvEFSTable->halnv.tables.defaultCountryTable.regDomain = NUM_REG_DOMAINS-1;
+                  wiphy_dbg(wiphy, "info: init time default country code is %c%c%c\n",
+                  pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0],
+                      pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1],
+                         pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2]);
+               }
+               else /* second or later CRDA request after init time */
+               {
+                  wiphy_dbg(wiphy, "info: crda none-default country code is %c%c\n",
+                      request->alpha2[0], request->alpha2[1]);
+               }
+               // hdd will read regd for this country after complete
+            }
+            complete(&pHddCtx->driver_crda_req);
+         }
+         else
+         {
+            nBandCapability = pHddCtx->cfg_ini->nBandCapability;
+            for (i=0, m=0; i<IEEE80211_NUM_BANDS; i++)
+            {
+
+               if (NULL == wiphy->bands[i])
+               {
+                  VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+                       "error: wiphy->bands[i] is NULL, i = %d", i);
+                  continue;
+               }
+
+               // internal channels[] is one continous array for both 2G and 5G bands
+               // m is internal starting channel index for each band
+               if (0 == i)
+                  m = 0;
+               else
+                  m = wiphy->bands[i-1]?wiphy->bands[i-1]->n_channels + m:m;
+
+               for (j=0; j<wiphy->bands[i]->n_channels; j++)
+               {
+                  // k = (m + j) is internal current channel index for 20MHz channel
+                  // n is internal channel index for corresponding 40MHz channel
+                  k = m + j;
+                  if (IEEE80211_BAND_2GHZ == i && eCSR_BAND_5G == nBandCapability) // 5G only
+                  {
+                     // Enable social channels for P2P
+                     if ((2412 == wiphy->bands[i]->channels[j].center_freq ||
+                         2437 == wiphy->bands[i]->channels[j].center_freq ||
+                         2462 == wiphy->bands[i]->channels[j].center_freq ) &&
+                         NV_CHANNEL_ENABLE == regChannels[k].enabled)
+                         wiphy->bands[i]->channels[j].flags &= ~IEEE80211_CHAN_DISABLED;
+                     else
+                         wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
+                     continue;
+                  }
+                  else if (IEEE80211_BAND_5GHZ == i && eCSR_BAND_24 == nBandCapability) // 2G only
+                  {
+                     wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
+                     continue;
+                  }
+
+                  if (NV_CHANNEL_DISABLE == regChannels[k].enabled ||
+                     NV_CHANNEL_INVALID == regChannels[k].enabled)
+                  {
+                     wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_DISABLED;
+                  }
+                  else if (NV_CHANNEL_DFS == regChannels[k].enabled)
+                  {
+                     wiphy->bands[i]->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
+                                                            |IEEE80211_CHAN_RADAR);
+                     wiphy->bands[i]->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+                  }
+                  else
+                  {
+                     wiphy->bands[i]->channels[j].flags &= ~(IEEE80211_CHAN_DISABLED
+                                                             |IEEE80211_CHAN_PASSIVE_SCAN
+                                                            |IEEE80211_CHAN_RADAR);
+                  }
+               }
+            }
+            /* Haven't seen any condition that will set by driver after init.
+             If we do, then we should also call sme_ChangeCountryCode */
+            for (j=0; j<wiphy->bands[IEEE80211_BAND_5GHZ ]->n_channels; j++)
+            {
+                // p2p UNII-1 band channels are passive when domain is FCC.
+                if ((wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].center_freq == 5180 ||
+                               wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5200 ||
+                               wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5220 ||
+                               wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5240) &&
+                               (ccode[0]== 'U'&& ccode[1]=='S'))
+                {
+                   wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+                }
+                else if ((wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].center_freq == 5180 ||
+                                    wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5200 ||
+                                    wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5220 ||
+                                    wiphy->bands[IEEE80211_BAND_5GHZ]->channels[j].center_freq == 5240) &&
+                                    (ccode[0]!= 'U'&& ccode[1]!='S'))
+                {
+                   wiphy->bands[IEEE80211_BAND_5GHZ ]->channels[j].flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+                }
+            }
+         }
+    }
+    else if (request->initiator == NL80211_REGDOM_SET_BY_CORE)
+    {
+       if (memcmp(pHddCtx->cfg_ini->crdaDefaultCountryCode,
+                        CFG_CRDA_DEFAULT_COUNTRY_CODE_DEFAULT , 2) == 0)
        {
-          pr_info("crda entry created.\n");
-          if (crda_alpha2[0] == request->alpha2[0] && crda_alpha2[1] == request->alpha2[1])
-          {  /* first CRDA request should be from init time */
-             /* Change default country code to CRDA country code, assume indoor */
-             pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0] = request->alpha2[0];
-             pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1] = request->alpha2[1];
-             pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2] = 'I';
-             pnvEFSTable->halnv.tables.defaultCountryTable.regDomain = NUM_REG_DOMAINS-1;
-             wiphy_dbg(wiphy, "info: init time default country code is %c%c%c\n",
-                pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[0],
-                   pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[1],
-                      pnvEFSTable->halnv.tables.defaultCountryTable.countryCode[2]);
-          }
-          else /* second or later CRDA request after init time */
-          {
-             wiphy_dbg(wiphy, "info: crda none-default country code is %c%c\n",
-                request->alpha2[0], request->alpha2[1]);
-          }
-          // hdd will read regd for this country after complete
+          request->processed = 1;
        }
-       complete(&pHddCtx->driver_crda_req);
-
-       /* Haven't seen any condition that will set by driver after init.
-          If we do, then we should also call sme_ChangeCountryCode */
     }
+
 return 0;
 }
-- 
1.8.2

