From caa5fa7eee3d657b909abd6a918a4dbe5de6ea0a Mon Sep 17 00:00:00 2001
From: Madan Mohan Koyyalamudi <mkoyya@codeaurora.org>
Date: Fri, 6 Sep 2013 16:12:25 -0700
Subject: [PATCH] Fix for transmitted data rate not in supported rates

Host is populating Self STA data rates in AddBss instead of Peer
Data rates to firmware.this commit corrects it and populates peer
data rates to firmware

Change-Id: Id50fc2feecb4ac20ab169682d34b64d90525b7e1
CRs-fixed: 536559
---
 CORE/MAC/src/pe/lim/limAssocUtils.c            | 161 ++++++++++++++++++++++++-
 CORE/MAC/src/pe/lim/limAssocUtils.h            |  15 +++
 CORE/MAC/src/pe/lim/limFT.c                    |   4 +-
 CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c |   4 +-
 4 files changed, 174 insertions(+), 10 deletions(-)

diff --git a/CORE/MAC/src/pe/lim/limAssocUtils.c b/CORE/MAC/src/pe/lim/limAssocUtils.c
index 77bf7b4..38d54ee 100644
--- a/CORE/MAC/src/pe/lim/limAssocUtils.c
+++ b/CORE/MAC/src/pe/lim/limAssocUtils.c
@@ -1800,7 +1800,147 @@ limPopulateOwnRateSet(tpAniSirGlobal pMac,
     return eSIR_FAILURE;
 } /*** limPopulateOwnRateSet() ***/
 
-/**
+#ifdef WLAN_FEATURE_11AC
+tSirRetStatus
+limPopulatePeerRateSet(tpAniSirGlobal pMac,
+                       tpSirSupportedRates pRates,
+                       tANI_U8* pSupportedMCSSet,
+                       tANI_U8 basicOnly,
+                       tpPESession psessionEntry,
+                       tDot11fIEVHTCaps *pVHTCaps)
+#else
+tSirRetStatus
+limPopulatePeerRateSet(tpAniSirGlobal pMac,
+                       tpSirSupportedRates pRates,
+                       tANI_U8* pSupportedMCSSet,
+                       tANI_U8 basicOnly,
+                       tpPESession psessionEntry)
+#endif
+{
+    tSirMacRateSet          tempRateSet;
+    tSirMacRateSet          tempRateSet2;
+    tANI_U32                i,j,val,min,isArate;
+    isArate = 0;
+    /* copy operational rate set from psessionEntry */
+    if ( psessionEntry->rateSet.numRates < SIR_MAC_RATESET_EID_MAX )
+    {
+        palCopyMemory(pMac->hHdd,(tANI_U8 *)tempRateSet.rate,(tANI_U8*)
+        (psessionEntry->rateSet.rate), psessionEntry->rateSet.numRates);
+        tempRateSet.numRates = psessionEntry->rateSet.numRates;
+    }
+    else
+    {
+        limLog(pMac, LOGE, FL("more than SIR_MAC_RATESET_EID_MAX rates\n"));
+        goto error;
+    }
+    if (psessionEntry->dot11mode == WNI_CFG_PHY_MODE_11G)
+    {
+       if (psessionEntry->extRateSet.numRates < SIR_MAC_RATESET_EID_MAX)
+       {
+           palCopyMemory(pMac->hHdd,(tANI_U8 *)tempRateSet2.rate, (tANI_U8*)
+          (psessionEntry->extRateSet.rate), psessionEntry->extRateSet.numRates);
+           tempRateSet2.numRates = psessionEntry->extRateSet.numRates;
+       }
+       else
+       {
+            limLog(pMac, LOGE, FL("psessionEntry->extRateSet.numRates
+             more than SIR_MAC_RATESET_EID_MAX rates\n"));
+            goto error;
+       }
+    }
+    else
+    tempRateSet2.numRates = 0;
+    if ((tempRateSet.numRates + tempRateSet2.numRates) > 12)
+    {
+       //we are in big trouble
+       limLog(pMac, LOGP, FL("more than 12 rates in CFG"));
+       goto error;
+    }
+    //copy all rates in tempRateSet, there are 12 rates max
+    for (i = 0;i < tempRateSet2.numRates; i++)
+    tempRateSet.rate[i + tempRateSet.numRates] = tempRateSet2.rate[i];
+    tempRateSet.numRates += tempRateSet2.numRates;
+     /**
+      ** Sort rates in tempRateSet (they are likely to be already sorted)
+     ** put the result in pSupportedRates
+     **/
+    {
+       tANI_U8 aRateIndex = 0;
+       tANI_U8 bRateIndex = 0;
+       palZeroMemory( pMac->hHdd, (tANI_U8 *) pRates, sizeof(tSirSupportedRates));
+       for(i = 0;i < tempRateSet.numRates; i++)
+       {
+          min = 0;
+          val = 0xff;
+          isArate = 0;
+          for(j = 0; (j < tempRateSet.numRates) && (j < SIR_MAC_RATESET_EID_MAX); j++)
+          {
+             if ((tANI_U32) (tempRateSet.rate[j] & 0x7f) < val)
+             {
+                val = tempRateSet.rate[j] & 0x7f;
+                min = j;
+             }
+          }
+          if (sirIsArate(tempRateSet.rate[min] & 0x7f))
+              isArate = 1;
+          /*
+           ** HAL needs to know whether the rate is basic rate or not, as it needs to
+           ** update the response rate table accordingly. e.g. if one of the 11a rates is
+           ** basic rate, then that rate can be used for sending control frames.
+           ** HAL updates the response rate table whenever basic rate set is changed.
+           **/
+          if (basicOnly)
+          {
+              if (tempRateSet.rate[min] & 0x80)
+              {
+                  if (isArate)
+                      pRates->llaRates[aRateIndex++] = tempRateSet.rate[min];
+                  else
+                      pRates->llbRates[bRateIndex++] = tempRateSet.rate[min];
+              }
+          }
+          else
+          {
+              if (isArate)
+                  pRates->llaRates[aRateIndex++] = tempRateSet.rate[min];
+              else
+                  pRates->llbRates[bRateIndex++] = tempRateSet.rate[min];
+          }
+          tempRateSet.rate[min] = 0xff;
+       }
+    }
+
+
+     if (IS_DOT11_MODE_HT(psessionEntry->dot11mode))
+     {
+       val = SIZE_OF_SUPPORTED_MCS_SET;
+       if (wlan_cfgGetStr(pMac, WNI_CFG_SUPPORTED_MCS_SET, &val)!= eSIR_SUCCESS)
+       {
+          /// Could not get rateset from CFG. Log error.
+          PELOGE(limLog(pMac, LOGE, FL("could not retrieve supportedMCSSet"));)
+          goto error;
+       }
+       //if supported MCS Set of the peer is passed in, then do the intersection
+       //else use the MCS set from local CFG.
+       if(pSupportedMCSSet != NULL)
+       {
+           for(i=0; i<SIR_MAC_MAX_SUPPORTED_MCS_SET; i++)
+           pRates->supportedMCSSet[i] &= pSupportedMCSSet[i];
+       }
+       PELOG2(limLog(pMac, LOG2, FL("MCS Rate Set Bitmap: "));)
+       for(i=0; i<SIR_MAC_MAX_SUPPORTED_MCS_SET; i++)
+       PELOGW(limLog(pMac, LOG2,FL("%x ") , pRates->supportedMCSSet[i]);)
+     }
+#ifdef WLAN_FEATURE_11AC
+    limPopulateVhtMcsSet(pMac, pRates , pVHTCaps,psessionEntry);
+#endif
+    return eSIR_SUCCESS;
+error:
+    return eSIR_FAILURE;
+} /*** limPopulatePeerRateSet() ***/
+
+
+ /**
  * limPopulateMatchingRateSet
  * FUNCTION:
  * This is called at the time of Association Request
@@ -3381,10 +3521,19 @@ tSirRetStatus limStaSendAddBss( tpAniSirGlobal pMac, tpSirAssocRsp pAssocRsp,
         pStaDs = dphGetHashEntry(pMac, DPH_STA_HASH_INDEX_PEER, &psessionEntry->dph.dphHashTable);
         if (pStaDs != NULL)
         {
+            vos_mem_set(&pStaDs->supportedRates, sizeof( tSirSupportedRates ), 0);
             limFillSupportedRatesInfo(pMac, pStaDs, &pStaDs->supportedRates,psessionEntry);
-            vos_mem_copy((tANI_U8*)&pAddBssParams->staContext.supportedRates,
-                                                (tANI_U8*)&pStaDs->supportedRates,
-                                                sizeof(tSirSupportedRates));
+#ifdef WLAN_FEATURE_11AC
+            limPopulatePeerRateSet(pMac, &pStaDs->supportedRates,
+            pAssocRsp->HTCaps.supportedMCSSet,
+            false,psessionEntry , &pAssocRsp->VHTCaps);
+#else
+            limPopulatePeerRateSet(pMac, &pStaDs->supportedRates,
+            pAssocRsp->HTCaps.supportedMCSSet, false,psessionEntry);
+#endif
+           vos_mem_copy((tANI_U8*)&pAddBssParams->staContext.supportedRates,
+           (tANI_U8*)&pStaDs->supportedRates,
+           sizeof(tSirSupportedRates));
         }
         else
             PELOGE(limLog(pMac, LOGE, FL("could not Update the supported rates."));)
@@ -3677,11 +3826,11 @@ tSirRetStatus limStaSendAddBssPreAssoc( tpAniSirGlobal pMac, tANI_U8 updateEntry
 
         //Update the rates
 #ifdef WLAN_FEATURE_11AC
-        limPopulateOwnRateSet(pMac, &pAddBssParams->staContext.supportedRates, 
+        limPopulatePeerRateSet(pMac, &pAddBssParams->staContext.supportedRates,
                                         pBeaconStruct->HTCaps.supportedMCSSet, false,psessionEntry,
                                         &pBeaconStruct->VHTCaps);
 #else
-        limPopulateOwnRateSet(pMac, &pAddBssParams->staContext.supportedRates, 
+        limPopulatePeerRateSet(pMac, &pAddBssParams->staContext.supportedRates,
                                         pBeaconStruct->HTCaps.supportedMCSSet, false,psessionEntry);
 #endif
         limFillSupportedRatesInfo(pMac, NULL, &pAddBssParams->staContext.supportedRates,psessionEntry);
diff --git a/CORE/MAC/src/pe/lim/limAssocUtils.h b/CORE/MAC/src/pe/lim/limAssocUtils.h
index 39fb47d..c45ff6e 100644
--- a/CORE/MAC/src/pe/lim/limAssocUtils.h
+++ b/CORE/MAC/src/pe/lim/limAssocUtils.h
@@ -94,6 +94,21 @@ tSirRetStatus limPopulateOwnRateSet(tpAniSirGlobal pMac,
 #endif
 
 #ifdef WLAN_FEATURE_11AC
+tSirRetStatus limPopulatePeerRateSet(tpAniSirGlobal pMac,
+                                     tpSirSupportedRates pRates,
+                                     tANI_U8* pSupportedMCSSet,
+                                     tANI_U8 basicOnly,
+                                     tpPESession psessionEntry,
+                                     tDot11fIEVHTCaps *pVHTCaps);
+#else
+tSirRetStatus limPopulatePeerRateSet(tpAniSirGlobal pMac,
+                                     tpSirSupportedRates pRates,
+                                     tANI_U8* pSupportedMCSSet,
+                                     tANI_U8 basicOnly,
+                                     tpPESession psessionEntry);
+#endif
+
+#ifdef WLAN_FEATURE_11AC
 tSirRetStatus
 limPopulateMatchingRateSet(tpAniSirGlobal pMac,
                            tpDphHashNode pStaDs,
diff --git a/CORE/MAC/src/pe/lim/limFT.c b/CORE/MAC/src/pe/lim/limFT.c
index 5354c2b..2f65a91 100644
--- a/CORE/MAC/src/pe/lim/limFT.c
+++ b/CORE/MAC/src/pe/lim/limFT.c
@@ -547,11 +547,11 @@ tSirRetStatus limFTPrepareAddBssReq( tpAniSirGlobal pMac,
 
         //Update the rates
 #ifdef WLAN_FEATURE_11AC
-        limPopulateOwnRateSet(pMac, &pAddBssParams->staContext.supportedRates,
+        limPopulatePeerRateSet(pMac, &pAddBssParams->staContext.supportedRates,
                              pBeaconStruct->HTCaps.supportedMCSSet,
                              false,pftSessionEntry,&pBeaconStruct->VHTCaps);
 #else
-        limPopulateOwnRateSet(pMac, &pAddBssParams->staContext.supportedRates,
+        limPopulatePeerRateSet(pMac, &pAddBssParams->staContext.supportedRates,
                                                     beaconStruct.HTCaps.supportedMCSSet, false,pftSessionEntry);
 #endif
         limFillSupportedRatesInfo(pMac, NULL, &pAddBssParams->staContext.supportedRates,pftSessionEntry);
diff --git a/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c b/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c
index c495ac6..07614bc 100644
--- a/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c
+++ b/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c
@@ -2819,9 +2819,9 @@ limProcessStaMlmAddBssRspFT(tpAniSirGlobal pMac, tpSirMsgQ limMsgQ, tpPESession
 
     pAddStaParams->shortPreambleSupported = (tANI_U8)psessionEntry->beaconParams.fShortPreamble;
 #ifdef WLAN_FEATURE_11AC
-    limPopulateOwnRateSet(pMac, &pAddStaParams->supportedRates, NULL, false,psessionEntry, NULL);
+    limPopulatePeerRateSet(pMac, &pAddStaParams->supportedRates, NULL, false,psessionEntry, NULL);
 #else
-    limPopulateOwnRateSet(pMac, &pAddStaParams->supportedRates, NULL, false,psessionEntry);
+    limPopulatePeerRateSet(pMac, &pAddStaParams->supportedRates, NULL, false,psessionEntry);
 #endif
 
     if( psessionEntry->htCapability)
-- 
1.8.2

